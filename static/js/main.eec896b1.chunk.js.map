{"version":3,"sources":["paper/PaperTools/PaperTools.module.css","paper/History/History.module.css","paper/utils.js","paper/tools/history.js","paper/tools/select.js","paper/index.js","paper/PaperTools/index.js","paper/History/index.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","restBindings","bind","paper","project","activeLayer","getItems","forEach","item","data","type","push","onAction","action","payload","itemName","values","processAction","updateItem","name","getItemsByName","match","indexOf","position","x","y","newPosition","Point","tweenTo","point","newPoint","content","excludedValues","Object","keys","filter","key","includes","undefined","addLine","path","Path","strokeColor","strokeWidth","length","start","moveTo","lineTo","add","selected","addCircle","Circle","fillColor","closed","addRect","Rectangle","addText","props","text","PointText","justification","onClick","save","json","exportJSON","localStorage","setItem","load","getItem","importJSON","history","onChangeListeners","getHistory","slice","revertHistory","record","pop","callback","segment","from","addToolSelect","tools","find","tool","Tool","minDistance","hitOptions","segments","stroke","fill","tolerance","onMouseDown","event","hitResult","hitTest","modifiers","shift","remove","location","insert","index","smooth","addChild","onMouseMove","onMouseDrag","to","delta","onMouseUp","subtract","Paper","memo","ref","useRef","actionQueue","useEffect","queue","current","setup","prevLayer","gridConfig","color","width","view","viewSize","height","drawLine","locked","Layer","lines","i","a","b","line","drawGridVerticalLines","drawGridHorizontalLines","activate","addGrid","onFrame","splice","setInterval","Array","map","Color","random","fetch","then","response","title","clearInterval","resize","PaperTools","url","sourceKey","destKey","console","log","className","styles","toolButton","History","useState","setHistory","App","isLocalhost","Boolean","window","hostname","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","catch","error","ReactDOM","render","document","getElementById","URL","process","href","origin","addEventListener","headers","contentType","get","status","ready","unregister","reload","checkValidServiceWorker"],"mappings":"mFACAA,EAAOC,QAAU,CAAC,MAAQ,0BAA0B,WAAa,iC,kBCAjED,EAAOC,QAAU,CAAC,QAAU,2B,uMCIjBC,EAAe,GAMbC,EAAO,WAEhBD,EAAe,GAEfE,IAAMC,QAAQC,YAAYC,WACrBC,SAAQ,SAAAC,GAEiB,SAAnBA,EAAKC,KAAKC,MACTT,EAAaU,KAAb,eACOH,EAAKC,WAMfG,EAAW,SAACC,GAAW,MAGGA,EAAOC,QAAlCN,EAHwB,EAGxBA,KAAMO,EAHkB,EAGlBA,SAAUC,EAHQ,EAGRA,OAElBC,EAAgB,SAACT,GACC,WAAhBK,EAAOH,MACPQ,EAAWV,EAAMQ,IAIrBD,GACAZ,IAAMC,QAAQE,SAAS,CACnBa,KAAMJ,IACPR,SAAQ,SAAAC,GACPS,EAAcT,MAIlBA,GACAS,EAAcT,IASTY,EAAiB,SAACD,GAC3B,OAAOhB,IAAMC,QAAQE,SAAS,CAC1Be,MAAO,SAACb,GAAD,OAA8C,KAAnCA,EAAKW,MAAQ,IAAIG,QAAQH,OAItCD,EAAa,SAAUV,EAAMQ,GAEtC,GAAIA,EAAOO,UAAYf,EAAKe,SAAU,CAElC,IAAMC,EAAIR,EAAOO,SAASC,GAAKhB,EAAKe,SAASC,EACvCC,EAAIT,EAAOO,SAASE,GAAKjB,EAAKe,SAASE,EACvCC,EAAc,IAAIvB,IAAMwB,MAAMH,EAAGC,GAEvCjB,EAAKoB,QACD,CAAE,SAAYF,GACd,KAIR,GAAIV,EAAOa,OAASrB,EAAKqB,MAAO,CAE5B,IAAML,EAAIR,EAAOa,MAAML,GAAKhB,EAAKqB,MAAML,EACjCC,EAAIT,EAAOa,MAAMJ,GAAKjB,EAAKqB,MAAMJ,EACjCK,EAAW,IAAI3B,IAAMwB,MAAMH,EAAGC,GAEpCjB,EAAKqB,MAAQC,EAGbd,EAAOe,SAAWvB,EAAKuB,UACvBvB,EAAKuB,QAAUf,EAAOe,SAG1B,IAAMC,EAAiB,CAAC,WAAY,QAAS,WAc7C,OAZAC,OAAOC,KAAKlB,GACPmB,QAAO,SAAAC,GAAG,OAAKJ,EAAeK,SAASD,MACvC7B,SAAQ,SAAA6B,QAEaE,IAAd9B,EAAK4B,IACL5B,EAAKoB,QAAL,eACOQ,EAAMpB,EAAOoB,IAChB,QAKT5B,GAGE+B,EAAU,WAEnB,IACMC,EAAO,IAAIrC,IAAMsC,KACvBD,EAAKE,YA1GyB,mBA2G9BF,EAAKG,YAAc,EACnBH,EAAKrB,KAJQ,OAIMC,EAJN,QAI2BwB,OAExC,IAAMC,EAAQ,IAAI1C,IAAMwB,MAAM,IAAK,KACnCa,EAAKM,OAAOD,GACZL,EAAKO,OAAOF,EAAMG,IAAI,CAAC,KAAM,MAE7B7C,IAAMC,QAAQC,YAAY4C,UAAW,EACrCT,EAAKS,UAAW,GAGPC,EAAY,WAErB,IACMV,EAAO,IAAIrC,IAAMsC,KAAKU,OAAO,IAAIhD,IAAMwB,MAAM,IAAK,KAAM,IAE9Da,EAAKY,UA5HuB,mBA6H5BZ,EAAKE,YA5HyB,mBA6H9BF,EAAKG,YAAc,EACnBH,EAAKa,QAAS,EACdb,EAAKrB,KAPQ,SAOMC,EAPN,UAO2BwB,OAExCzC,IAAMC,QAAQC,YAAY4C,UAAW,EACrCT,EAAKS,UAAW,GAGPK,EAAU,WAEnB,IACMd,EAAO,IAAIrC,IAAMsC,KAAKc,UAAU,EAAG,EAAG,IAAK,KAEjDf,EAAKY,UA3IuB,mBA4I5BZ,EAAKE,YA3IyB,mBA4I9BF,EAAKG,YAAc,EACnBH,EAAKa,QAAS,EACdb,EAAKrB,KAPQ,OAOMC,EAPN,QAO2BwB,OAExCzC,IAAMC,QAAQC,YAAY4C,UAAW,EACrCT,EAAKS,UAAW,GAGPO,EAAU,SAACC,GAEpB,IACM5B,EAAQ4B,EAAM5B,OAAS,IAAI1B,IAAMwB,MAAM,IAAK,KAC5CI,EAAU0B,EAAM1B,SAAW,OAE3B2B,EAAO,IAAIvD,IAAMwD,UAAU9B,GASjC,OARA6B,EAAKE,cAAgB,SACrBF,EAAKN,UAAY,QACjBM,EAAKf,YAAc,EACnBe,EAAK3B,QAAUA,EACf2B,EAAKvC,KATQ,OASMC,EATN,QAS2BwB,OAExCc,EAAKG,QAAUJ,EAAMI,QAEdH,GAqFEI,EAAO,WAChB,IAAMC,EAAO5D,IAAMC,QAAQC,YAAY2D,aACvCC,aAAaC,QAAQ,UAAWH,IAGvBI,EAAO,WAChB,IAAMJ,EAAOE,aAAaG,QAAQ,WAC9BL,GAEA5D,IAAMC,QAAQC,YAAYgE,WAAWN,ICjQvCO,EAAU,GAEVC,EAAoB,GAWbC,EAAa,WACtB,OAAOF,EAAQG,SAaNC,EAAgB,WAEzB,GAAuB,KAAb,OAAPJ,QAAO,IAAPA,OAAA,EAAAA,EAAS1B,QAAZ,CAIA,IAAM+B,EAASL,EAAQM,MAGvB,GAFAL,EAAkBhE,SAAQ,SAAAsE,GAAQ,OAAIA,EAASL,QAE3B,mBAAV,OAANG,QAAM,IAANA,OAAA,EAAAA,EAAQvC,KAAyB,CAAC,IAAD,EAEPuC,EAAO7D,QAAzBgE,EAFyB,EAEzBA,QAASC,EAFgB,EAEhBA,KAEbD,GACAlE,EAAS,CACLF,KAAM,SACNI,QAAS,CACLN,KAAMsE,EACN9D,OAAQ,CACJa,MAAOkD,SC9ClBC,EAAgB,WAIzB,IAAI7E,IAAM8E,MAAMC,MAAK,SAAAC,GAAI,MAFZ,eAEgBA,EAAKhE,QAAlC,CAIA,IAAIgE,EAAO,IAAIhF,IAAMiF,KACrBD,EAAKhE,KAPQ,aAQbgE,EAAKE,YAAc,EAEnB,IAOIP,EAAStC,EAPT8C,EAAa,CACbC,UAAU,EACVC,QAAQ,EACRC,MAAM,EACNC,UAAW,GAMfP,EAAKQ,YAAc,SAAUC,GAEzBd,EAAUtC,EAAO,KACjB,IAAIqD,EAAY1F,IAAMC,QAAQ0F,QAAQF,EAAM/D,MAAOyD,GAEnD,GAAKO,EAGL,GAAID,EAAMG,UAAUC,MACO,YAAnBH,EAAUnF,MACVmF,EAAUf,QAAQmB,aAF1B,CASA,GAFAzD,EAAOqD,EAAUrF,KAEM,YAAnBqF,EAAUnF,KACVoE,EAAUe,EAAUf,aAEnB,GAAuB,WAAnBe,EAAUnF,KAAmB,CAClC,IAAIwF,EAAWL,EAAUK,SACzBpB,EAAUtC,EAAK2D,OAAOD,EAASE,MAAQ,EAAGR,EAAM/D,OAChDW,EAAK6D,SAGqB,SAAnBR,EAAUnF,MAGjBP,IAAMC,QAAQC,YAAYiG,SAAST,EAAUrF,QAIrD2E,EAAKoB,YAAc,SAACX,GAEhB,GAAIA,EAAMpF,KAAM,CAEZ,GAAwB,WAApBoF,EAAMpF,KAAKW,KACX,OAGJhB,IAAMC,QAAQC,YAAY4C,UAAW,EACrC2C,EAAMpF,KAAKyC,UAAW,IAI9BkC,EAAKqB,YAAc,SAACZ,GAEhB,GAAId,EAAS,CACT,IAAM2B,EAAK3B,EAAQjD,MAAMmB,IAAI4C,EAAMc,OACnC5B,EAAQjD,MAAQ4E,OAGXjE,GAEDA,EAAKS,WACLT,EAAKjB,SAAWiB,EAAKjB,SAASyB,IAAI4C,EAAMc,SAKpDvB,EAAKwB,UAAY,SAAAf,GAEb,GAAId,EAAS,CAET,IAAMC,EAAOa,EAAM/D,MAAM+E,SAAShB,EAAMc,OAClCD,EAAKb,EAAM/D,MDpFArB,ECsFJ,CACT4B,IAAK,gBACLtB,QAAS,CACLgE,UACAC,OACA0B,OD1FhBnC,EAAQ3D,KAAKH,GACV8D,EAAQ1B,OALY,KAMnB0B,EAAQM,MAGZL,EAAkBhE,SAAQ,SAAAsE,GAAQ,OAAIA,EAASL,QANvB,IAAChE,KEiFdqG,EAnFDC,gBAAK,WAEf,IAAMC,EAAMC,mBACNC,EAAcD,iBAAO,IA2E3B,OAzEAE,qBAAU,WAEN,IAAMC,EAAQF,EAAYG,QAE1BjH,IAAMkH,MAAMN,EAAIK,SAGhBpC,IHwJe,WAEnB,IAAIsC,EAAYnH,IAAMC,QAAQC,YAExBkH,EAAa,CACfC,MAAO,mBACPC,MAAOtH,IAAMuH,KAAKC,SAASF,MAC3BG,OAAQzH,IAAMuH,KAAKC,SAASC,QAG1BC,EAAW,SAACtC,GAEd,IAAM/C,EAAO,IAAIrC,IAAMsC,KAAK8C,GAK5B,OAJA/C,EAAKE,YAAc,mBACnBF,EAAKG,YAAc,EACnBH,EAAKsF,QAAS,EAEPtF,IAwDK,IAAIrC,IAAM4H,OAChB5G,KAAO,aAtDa,SAAC,GAQ3B,IAJG,IAHHqG,EAGE,EAHFA,MACAC,EAEE,EAFFA,MACAG,EACE,EADFA,OAGII,EAAQ,GAEHC,EAAI,EAAGA,EAAIR,EAAOQ,IAEvB,GAAIA,EAAI,KAAO,EAAG,CACd,IAAIC,EAAI,IAAI/H,IAAMwB,MAAMsG,EAAG,GACvBE,EAAI,IAAIhI,IAAMwB,MAAMsG,EAAGL,GAEvBQ,EAAOP,EADI,CAACK,EAAGC,IAGnBC,EAAK1F,YAAc8E,EACnBY,EAAKzF,YAAcsF,EAAI,KAAO,EAAI,EAAI,EAEtCD,EAAMrH,KAAKyH,IAqCvBC,CAAsBd,GA9BU,SAAC,GAQ7B,IAJG,IAHHC,EAGE,EAHFA,MACAC,EAEE,EAFFA,MACAG,EACE,EADFA,OAGII,EAAQ,GAEHC,EAAI,EAAGA,EAAIL,EAAQK,IAExB,GAAIA,EAAI,KAAO,EAAG,CAEd,IAAIC,EAAI,IAAI/H,IAAMwB,MAAM,EAAGsG,GACvBE,EAAI,IAAIhI,IAAMwB,MAAM8F,EAAOQ,GAE3BG,EAAOP,EADI,CAACK,EAAGC,IAGnBC,EAAK1F,YAAc8E,EACnBY,EAAKzF,YAAcsF,EAAI,KAAO,EAAI,EAAI,EAEtCD,EAAMrH,KAAKyH,IAWvBE,CAAwBf,GAExBD,EAAUiB,WGtONC,GAEArE,IACAjE,IAEAC,IAAMuH,KAAKe,QAAU,SAAC7C,GAClB,GAAIuB,EAAMvE,OAAS,EAAG,CAElB,IAAM/B,EAASsG,EAAMA,EAAMvE,OAAS,GACpChC,EAASC,GAET,IAAMuF,EAAQe,EAAM7F,QAAQT,GACxBuF,GAAS,GACTe,EAAMuB,OAAOtC,EAAO,KAMhC,IAAI8B,EAAIS,aAAY,WAEhB,IAAIC,MAAM,IACLnD,KAAK,MACLoD,KAAI,SAAChI,EAAQuF,GAAT,MAAoB,CACrB1F,KAAM,SACNI,QAAS,CACLC,SAAU,OAASqF,EACnBpF,OAAQ,CACJoC,UAAWjD,IAAM2I,MAAMC,eAIlCxI,SAAQ,SAAAM,GACLsG,EAAMxG,KAAKE,QAGpB,KAECsH,EAAIQ,aAAY,WAEhBK,MAAM,gDACDC,MAAK,SAAAC,GAAQ,OAAIA,EAASnF,UAC1BkF,MAAK,SAAAlF,GAEF,IAAMlD,EAAS,CACXH,KAAM,SACNI,QAAS,CACLC,SAAU,QACVC,OAAQ,CACJe,QAASgC,EAAKoF,SAK1BhC,EAAMxG,KAAKE,QAGpB,KAGCuI,cAAclB,GACdkB,cAAcjB,KAEnB,IAGC,4BAAQpB,IAAKA,EAAKsC,OAAO,c,gBCvBlBC,EAtDIxC,gBAAK,WAEpB,IAAM7B,EAAQ,CACV,CAAEkE,MAAO,WAAYtF,QAAStB,GAC9B,CAAE4G,MAAO,aAActF,QAASX,GAChC,CAAEiG,MAAO,WAAYtF,QAASP,GAC9B,CAAE6F,MAAO,WAAYtF,QAASL,GAC9B,CAAE2F,MAAO,OAAQtF,QAASC,GAC1B,CAAEqF,MAAO,OAAQtF,QAASM,GAC1B,CAAEgF,MAAO,OAAQtF,QAASa,GAC1B,CACIyE,MAAO,OACPtF,QAAS,WAIL1D,IAAMC,QAAQE,SAAS,CACnBa,KAHa,UAIdZ,SAAQ,SAAAC,GAQPA,EAAKC,KAAL,eACOD,EAAKC,KADZ,CAEIC,KAAM,OACN6I,IAAK,+CACLC,UAAW,QACXC,QAAS,YAEbC,QAAQC,IAAI,eACZzJ,UAMhB,OACI,yBAAK0J,UAAS,UAAKC,IAAO5E,MAAZ,aACTA,EAAM4D,KAAI,SAAC1D,EAAMiB,GAAP,OACP,4BACIhE,IAAKgE,EACLwD,UAAWC,IAAOC,WAClBjG,QAASsB,EAAKtB,SACbsB,EAAKgE,c,uBC9BXY,EAnBCjD,gBAAK,WAAO,IJoDIjC,EIpDL,EAEYmF,mBAASxF,KAFrB,0BAEhBF,OAFgB,MAEN,GAFM,EAEF2F,EAFE,KAOvB,OJ6C4BpF,EIjDZ,SAAAP,GACZ2F,EAAW3F,IJiDfC,EAAkB5D,KAAKkE,GI7CnB,wBAAI+E,UAAWC,IAAOvF,SACjBA,EAAQuE,KAAI,SAACrI,EAAM4F,GAAP,mBACT,wBAAIhE,IAAKgE,GAAT,UAEQ5F,EAAK4B,IAFb,6BAE2B5B,EAAKM,eAFhC,aAE2B,EAAciE,KAAKvD,EAF9C,sBAEmDhB,EAAKM,eAFxD,aAEmD,EAAciE,KAAKtD,EAFtE,yBAE8EjB,EAAKM,eAFnF,aAE8E,EAAc2F,GAAGjF,EAF/F,sBAEoGhB,EAAKM,eAFzG,aAEoG,EAAc2F,GAAGhF,WCAtHyI,MAVf,WACE,OACE,oCACE,kBAAC,EAAD,MACA,kBAAC,EAAD,MACA,kBAAC,EAAD,QCAAC,EAAcC,QACW,cAA7BC,OAAOnE,SAASoE,UAEe,UAA7BD,OAAOnE,SAASoE,UAEhBD,OAAOnE,SAASoE,SAASjJ,MACvB,2DAsCN,SAASkJ,EAAgBC,EAAOC,GAC9BC,UAAUC,cACPC,SAASJ,GACTvB,MAAK,SAAA4B,GACJA,EAAaC,cAAgB,WAC3B,IAAMC,EAAmBF,EAAaG,WACd,MAApBD,IAGJA,EAAiBE,cAAgB,WACA,cAA3BF,EAAiBG,QACfR,UAAUC,cAAcQ,YAI1BzB,QAAQC,IACN,iHAKEc,GAAUA,EAAOW,UACnBX,EAAOW,SAASP,KAMlBnB,QAAQC,IAAI,sCAGRc,GAAUA,EAAOY,WACnBZ,EAAOY,UAAUR,WAO5BS,OAAM,SAAAC,GACL7B,QAAQ6B,MAAM,4CAA6CA,MC1FjEC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SDgB1C,SAAkBlB,GACvB,GAA6C,kBAAmBC,UAAW,CAGzE,GADkB,IAAIkB,IAAIC,SAAwBxB,OAAOnE,SAAS4F,MACpDC,SAAW1B,OAAOnE,SAAS6F,OAIvC,OAGF1B,OAAO2B,iBAAiB,QAAQ,WAC9B,IAAMxB,EAAK,UAAMqB,SAAN,sBAEP1B,IAgEV,SAAiCK,EAAOC,GAEtCzB,MAAMwB,EAAO,CACXyB,QAAS,CAAE,iBAAkB,YAE5BhD,MAAK,SAAAC,GAEJ,IAAMgD,EAAchD,EAAS+C,QAAQE,IAAI,gBAEnB,MAApBjD,EAASkD,QACO,MAAfF,IAA8D,IAAvCA,EAAY5K,QAAQ,cAG5CoJ,UAAUC,cAAc0B,MAAMpD,MAAK,SAAA4B,GACjCA,EAAayB,aAAarD,MAAK,WAC7BoB,OAAOnE,SAASqG,eAKpBhC,EAAgBC,EAAOC,MAG1Ba,OAAM,WACL5B,QAAQC,IACN,oEAvFA6C,CAAwBhC,EAAOC,GAI/BC,UAAUC,cAAc0B,MAAMpD,MAAK,WACjCS,QAAQC,IACN,iHAMJY,EAAgBC,EAAOC,OCtC/BE,K","file":"static/js/main.eec896b1.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"tools\":\"PaperTools_tools__1gGrH\",\"toolButton\":\"PaperTools_toolButton__3H_SE\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"history\":\"History_history__3cTjF\"};","import paper from 'paper';\n\nexport const defaultFillColor = 'rgba(0,0,0,0.87)';\nexport const defaultStrokeColor = 'rgba(0,0,0,0.87)';\n\nexport let restBindings = [];\n\nexport const initCanvas = (canvas) => {\n    paper.setup(canvas);\n};\n\nexport const bind = () => {\n\n    restBindings = [];\n\n    paper.project.activeLayer.getItems()\n        .forEach(item => {\n\n            if(item.data.type === 'rest') {\n                restBindings.push({\n                    ...item.data\n                })\n            }\n        })\n};\n\nexport const onAction = (action) => {\n    // console.log(\"on Action:\", action);\n\n    const { item, itemName, values } = action.payload;\n\n    const processAction = (item) => {\n        if (action.type === \"update\") {\n            updateItem(item, values);\n        }\n    };\n\n    if (itemName) {\n        paper.project.getItems({\n            name: itemName\n        }).forEach(item => {\n            processAction(item);\n        });\n    }\n\n    if (item) {\n        processAction(item);\n    }\n};\n\nexport const useTool = (name) => {\n    const tool = paper.tools.find(tool => tool.name === name)\n    tool.activate()\n}\n\nexport const getItemsByName = (name) => {\n    return paper.project.getItems({\n        match: (item) => (item.name || \"\").indexOf(name) === 0\n    });\n};\n\nexport const updateItem = function (item, values) {\n\n    if (values.position && item.position) {\n\n        const x = values.position.x || item.position.x;\n        const y = values.position.y || item.position.y;\n        const newPosition = new paper.Point(x, y);\n\n        item.tweenTo(\n            { 'position': newPosition },\n            300\n        );\n    }\n\n    if (values.point && item.point) {\n\n        const x = values.point.x || item.point.x;\n        const y = values.point.y || item.point.y;\n        const newPoint = new paper.Point(x, y);\n\n        item.point = newPoint;\n    }\n\n    if (values.content && item.content) {\n        item.content = values.content;\n    }\n\n    const excludedValues = [\"position\", \"point\", \"content\"];\n\n    Object.keys(values)\n        .filter(key => !excludedValues.includes(key))\n        .forEach(key => {\n\n            if (item[key] !== undefined) {\n                item.tweenTo(\n                    { [key]: values[key] },\n                    300\n                );\n            }\n        });\n\n    return item;\n};\n\nexport const addLine = () => {\n\n    const name = \"line\";\n    const path = new paper.Path();\n    path.strokeColor = defaultStrokeColor;\n    path.strokeWidth = 2;\n    path.name = name + getItemsByName(name).length;\n\n    const start = new paper.Point(100, 100);\n    path.moveTo(start);\n    path.lineTo(start.add([200, -50]));\n\n    paper.project.activeLayer.selected = false;\n    path.selected = true;\n};\n\nexport const addCircle = () => {\n\n    const name = \"circle\";\n    const path = new paper.Path.Circle(new paper.Point(100, 100), 50);\n\n    path.fillColor = defaultFillColor;\n    path.strokeColor = defaultStrokeColor;\n    path.strokeWidth = 2;\n    path.closed = true;\n    path.name = name + getItemsByName(name).length;\n\n    paper.project.activeLayer.selected = false;\n    path.selected = true;\n};\n\nexport const addRect = () => {\n\n    const name = \"rect\";\n    const path = new paper.Path.Rectangle(0, 0, 100, 100);\n\n    path.fillColor = defaultFillColor;\n    path.strokeColor = defaultStrokeColor;\n    path.strokeWidth = 2;\n    path.closed = true;\n    path.name = name + getItemsByName(name).length;\n\n    paper.project.activeLayer.selected = false;\n    path.selected = true;\n};\n\nexport const addText = (props) => {\n\n    const name = \"text\";\n    const point = props.point || new paper.Point(100, 100);\n    const content = props.content || \"Text\";\n\n    const text = new paper.PointText(point);\n    text.justification = 'center';\n    text.fillColor = 'black';\n    text.strokeWidth = 2;\n    text.content = content;\n    text.name = name + getItemsByName(name).length;\n\n    text.onClick = props.onClick;\n\n    return text;\n};\n\nexport const addGrid = () => {\n\n    var prevLayer = paper.project.activeLayer;\n\n    const gridConfig = {\n        color: 'rgba(0,0,0,0.11)',\n        width: paper.view.viewSize.width,\n        height: paper.view.viewSize.height\n    };\n\n    const drawLine = (segments) => {\n\n        const path = new paper.Path(segments);\n        path.strokeColor = 'rgba(0,0,0,0.21)';\n        path.strokeWidth = 1;\n        path.locked = true;\n\n        return path;\n    };\n\n    const drawGridVerticalLines = ({\n        color,\n        width,\n        height\n    }) => {\n\n        let lines = [];\n\n        for (var i = 0; i < width; i++) {\n\n            if (i % 10 === 0) {\n                var a = new paper.Point(i, 0);\n                var b = new paper.Point(i, height);\n                var segments = [a, b];\n                var line = drawLine(segments);\n\n                line.strokeColor = color;\n                line.strokeWidth = i % 50 === 0 ? 2 : 1;\n\n                lines.push(line);\n            }\n        }\n\n        return lines;\n    }\n\n    const drawGridHorizontalLines = ({\n        color,\n        width,\n        height\n    }) => {\n\n        let lines = [];\n\n        for (var i = 0; i < height; i++) {\n\n            if (i % 10 === 0) {\n\n                var a = new paper.Point(0, i);\n                var b = new paper.Point(width, i);\n                var segments = [a, b];\n                var line = drawLine(segments);\n\n                line.strokeColor = color;\n                line.strokeWidth = i % 50 === 0 ? 2 : 1;\n\n                lines.push(line);\n            }\n        }\n\n        return lines;\n    }\n\n    var gridLayer = new paper.Layer();\n    gridLayer.name = \"grid-layer\";\n\n    drawGridVerticalLines(gridConfig);\n    drawGridHorizontalLines(gridConfig);\n\n    prevLayer.activate();\n};\n\nexport const save = () => {\n    const json = paper.project.activeLayer.exportJSON();\n    localStorage.setItem('project', json);\n};\n\nexport const load = () => {\n    const json = localStorage.getItem('project');\n    if (json) {\n        // paper.project.clear();\n        paper.project.activeLayer.importJSON(json)\n    }\n};","\nimport { onAction } from \"../utils\";\n\nconst history = [];\nconst MAX_HISTORY_LENGTH = 1000;\nconst onChangeListeners = [];\n\nexport const addToHistory = (item) => {\n    history.push(item);\n    if(history.length > MAX_HISTORY_LENGTH) {\n        history.pop();\n    }\n\n    onChangeListeners.forEach(callback => callback(getHistory()));\n}\n\nexport const getHistory = () => {\n    return history.slice();\n}\n\nexport const removeFromHistory = (item) => {\n\n    const index = history.indexOf(item);\n\n    if (index > -1) {\n        history.splice(index, 1);\n        onChangeListeners.forEach(callback => callback(history));\n    }\n}\n\nexport const revertHistory = () => {\n\n    if(history?.length === 0) {\n        return;\n    }\n\n    const record = history.pop();\n    onChangeListeners.forEach(callback => callback(getHistory()));\n    \n    if (record?.key === \"segment.point\") {\n\n        const { segment, from } = record.payload;\n\n        if (segment) {\n            onAction({\n                type: \"update\",\n                payload: {\n                    item: segment,\n                    values: {\n                        point: from\n                    }\n                }\n            });\n        }\n    }\n}\n\nexport const onHistoryChange = (callback) => {\n    onChangeListeners.push(callback);\n}","import paper from 'paper';\nimport { addToHistory } from './history';\n\nexport const addToolSelect = () => {\n\n    const name = \"toolSelect\";\n\n    if (paper.tools.find(tool => tool.name === name)) {\n        return;\n    }\n\n    var tool = new paper.Tool();\n    tool.name = name;\n    tool.minDistance = 5;\n\n    var hitOptions = {\n        segments: true,\n        stroke: true,\n        fill: true,\n        tolerance: 5\n    };\n\n    var segment, path;\n    var movePath = false;\n\n    tool.onMouseDown = function (event) {\n\n        segment = path = null;\n        var hitResult = paper.project.hitTest(event.point, hitOptions);\n\n        if (!hitResult)\n            return;\n\n        if (event.modifiers.shift) {\n            if (hitResult.type === 'segment') {\n                hitResult.segment.remove();\n            };\n            return;\n        }\n\n        path = hitResult.item;\n\n        if (hitResult.type === 'segment') {\n            segment = hitResult.segment;\n        }\n        else if (hitResult.type === 'stroke') {\n            var location = hitResult.location;\n            segment = path.insert(location.index + 1, event.point);\n            path.smooth();\n        }\n\n        movePath = hitResult.type === 'fill';\n\n        if (movePath) {\n            paper.project.activeLayer.addChild(hitResult.item);\n        }\n    };\n\n    tool.onMouseMove = (event) => {\n\n        if (event.item) {\n\n            if (event.item.name === 'button') {\n                return;\n            }\n\n            paper.project.activeLayer.selected = false;\n            event.item.selected = true;\n        }\n    };\n\n    tool.onMouseDrag = (event) => {\n\n        if (segment) {\n            const to = segment.point.add(event.delta);\n            segment.point = to;\n            // path.smooth();\n        }\n        else if (path) {\n\n            if (path.selected) {\n                path.position = path.position.add(event.delta);\n            }\n        }\n    };\n\n    tool.onMouseUp = event => {\n\n        if (segment) {\n\n            const from = event.point.subtract(event.delta);\n            const to = event.point;\n    \n            addToHistory({\n                key: 'segment.point',\n                payload: {\n                    segment,\n                    from,\n                    to\n                }\n            });\n        }\n    };\n}\n","import React, { useEffect, memo, useRef } from 'react';\nimport paper from 'paper';\nimport { addGrid, load, bind, onAction } from './utils';\nimport { addToolSelect } from './tools/select';\n\nconst Paper = memo(() => {\n\n    const ref = useRef();\n    const actionQueue = useRef([]);\n\n    useEffect(() => {\n\n        const queue = actionQueue.current;\n\n        paper.setup(ref.current);\n        // initTools();\n\n        addToolSelect();\n        addGrid();\n\n        load();\n        bind();\n\n        paper.view.onFrame = (event) => {\n            if (queue.length > 0) {\n\n                const action = queue[queue.length - 1];\n                onAction(action);\n    \n                const index = queue.indexOf(action);\n                if (index > -1) {\n                    queue.splice(index, 1);\n                }\n            }\n        }\n\n        // TODO REMOVE\n        var a = setInterval(() => {\n\n            new Array(10)\n                .fill(null)\n                .map((action, index) => ({\n                    type: \"update\",\n                    payload: {\n                        itemName: \"rect\" + index,\n                        values: {\n                            fillColor: paper.Color.random()\n                        }\n                    }\n                }))\n                .forEach(action => {\n                    queue.push(action);\n                });\n    \n        }, 1000);\n    \n        var b = setInterval(() => {\n    \n            fetch('https://jsonplaceholder.typicode.com/todos/1')\n                .then(response => response.json())\n                .then(json => {\n    \n                    const action = {\n                        type: \"update\",\n                        payload: {\n                            itemName: \"text\" + 1,\n                            values: {\n                                content: json.title\n                            }\n                        }\n                    }\n    \n                    queue.push(action);\n                })\n    \n        }, 5000);\n    \n        // return () => {\n            clearInterval(a);\n            clearInterval(b);\n        // }\n    }, []);\n\n    return (\n        <canvas ref={ref} resize=\"resize\"></canvas>\n    );\n});\n\nexport default Paper;\n","import React, { memo } from 'react';\nimport paper from 'paper';\nimport { addLine, addCircle, addRect, addText, save, load, bind } from '../utils';\nimport { revertHistory } from '../tools/history';\n\nimport styles from './PaperTools.module.css';\n\nconst PaperTools = memo(() => {\n\n    const tools = [\n        { title: \"Add Line\", onClick: addLine },\n        { title: \"Add Circle\", onClick: addCircle },\n        { title: \"Add Rect\", onClick: addRect },\n        { title: \"Add Text\", onClick: addText },\n        { title: \"Save\", onClick: save },\n        { title: \"Load\", onClick: load },\n        { title: \"Undo\", onClick: revertHistory },\n        {\n            title: \"Bind\",\n            onClick: () => {\n\n                const itemName = 'text0';\n\n                paper.project.getItems({\n                    name: itemName\n                }).forEach(item => {\n                    // bindItem(item, {\n                    //     type: 'rest',\n                    //     url: 'https://jsonplaceholder.typicode.com/todos/1',\n                    //     sourceKey: 'title',\n                    //     destKey: 'content'\n                    // })\n\n                    item.data = {\n                        ...item.data,\n                        type: 'rest',\n                        url: 'https://jsonplaceholder.typicode.com/todos/1',\n                        sourceKey: 'title',\n                        destKey: 'content'\n                    }\n                    console.log(\"item binded\");\n                    bind();\n                });\n            }\n        }\n    ];\n\n    return (\n        <div className={`${styles.tools} tools-0`}>\n            {tools.map((tool, index) =>\n                <button\n                    key={index}\n                    className={styles.toolButton}\n                    onClick={tool.onClick}>\n                    {tool.title}\n                </button>\n            )}\n        </div>\n    );\n});\n\nexport default PaperTools;\n","import React, { memo, useState } from \"react\";\nimport { getHistory, onHistoryChange } from \"../tools/history\";\n\nimport styles from './History.module.css';\n\nconst History = memo(() => {\n\n    const [history = [], setHistory] = useState(getHistory());\n    onHistoryChange(history => {\n        setHistory(history);\n    });\n\n    return (\n        <ul className={styles.history}>\n            {history.map((item, index) =>\n                <li key={index}>\n                    {/* {`${item.key}: x/y=${item.payload?.from.x}=>${item.payload?.to.x} y=${item.payload?.from.y}=>${item.payload?.to.y}`} */}\n                    {`${item.key}: x/y = ${item.payload?.from.x}/${item.payload?.from.y} -> ${item.payload?.to.x}/${item.payload?.to.y}`}\n                </li>\n            )}\n        </ul>\n    );\n});\n\nexport default History;\n","import React from 'react';\nimport Paper from './paper';\nimport PaperTools from './paper/PaperTools';\nimport History from './paper/History';\n\n// import './App.css';\n\nfunction App() {\n  return (\n    <>\n      <Paper />\n      <PaperTools />\n      <History />\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n\nserviceWorker.register();\n\n// serviceWorker.register({\n//     onUpdate: () => alert(\"New content is available and will be used when all tabs for this page are closed.\"),\n//     onSuccess: () => () => {\n//         alert(\"Content is cached for offline use.\");\n\n//     }\n// });\n\n// setInterval(() => {\n\n//     navigator.serviceWorker.getRegistration()\n//         .then(registration => {\n//             registration.update();\n\n//         });\n\n// }, 3000);\n"],"sourceRoot":""}